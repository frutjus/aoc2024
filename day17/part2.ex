defmodule AoC do
    def zip_tail_with(xs, f) do
        Enum.zip_with(tl(xs), Enum.drop(xs, -1), f)
    end

    def heads(xs) do
        Enum.scan(xs, [], fn item, acc ->
            acc ++ [item]
        end)
    end

    def tails(xs) do
        Enum.scan(xs, xs, fn _, acc ->
            tl(acc)
        end)
    end

    def tails1(xs) do
        [xs | tails(xs)]
    end

    def transpose(rows) do
        rows
        |> List.zip
        |> Enum.map(&Tuple.to_list/1)
    end

    @spec iterate_until(state, (state -> {boolean, state | term()})) :: state when state: var
    def iterate_until(state, function) do
        case function.(state) do
            {:iterate, new_state} -> iterate_until(new_state, function)
            {:stop, final_answer} -> final_answer
        end
    end

    def pairs(xs) do
        for {a, ai} <- Enum.with_index(xs),
            {b, bi} <- Enum.with_index(xs),
            ai != bi do
                {a,b}
        end
    end

    def insert_ordered(list, elem, f \\ &Function.identity/1)
    def insert_ordered([], elem, _) do
        [elem]
    end
    def insert_ordered([l | list], elem, f) do
        if f.(l) < f.(elem) do
            [l | insert_ordered(list, elem, f)]
        else
            [elem, l | list]
        end
    end

    def map_map(map, f) do
        for {key, val} <- map,
            into: %{} do
            {key, f.(val)}
        end
    end

    def grid_to_coords(str) do
        for {rw, r} <- str
                    |> String.split("\r\n")
                    |> Enum.with_index(),
            {ch, c} <-  rw
                    |> String.split("", trim: true)
                    |> Enum.with_index()
            do
            {{r,c}, ch}
        end
    end

    def mod(n, m) do
        remainder = rem(n, m)
        if remainder < 0 do
            remainder + m
        else
            remainder
        end
    end

    def map_move(map, key, newkey) do
        {val,new_map} = Map.pop!(map, key)
        if Map.has_key?(map, newkey) do
            raise "can't move #{key}; #{newkey} already exists!"
        else
            Map.put(new_map, newkey, val)
        end
    end
end

import Enum

# This solution is specifically designed for the program I was given as puzzle input.
# The instruction listing for that program is as follows (generated by disassemble.ex):
# ip | raw | instr | description
# 0  | 2 4 | bst a | b = a % 8
# 2  | 1 2 | bxl 2 | b = b xor 2
# 4  | 7 5 | adv b | c = a / 2^b
# 6  | 4 7 | bxc 7 | b = b xor c
# 8  | 1 3 | bxl 3 | b = b xor 3
# 10 | 5 5 | out b | out b % 8
# 12 | 0 3 | adv 3 | a = a / 2^3
# 14 | 3 0 | jnz 0 | if a != 0: jmp 0
#
# So in a nutshell, the program is going to loop once for every 3 bits in register A,
# and output some value based on a function of those 3 bits (as well as some number of higher bits in A, as per the third instruction).
# To produce the original program as output, it has to loop 16 times (since the program has 16 numbers), so we know that the value of A must have 48 (3 * 16) bits.
# More specifically, the value must lie between 2^45 and 2^48 - 1. This is too large a range to search through, but we can search it three bits at a time.
# First we find the highest 3 bits of A such that, when run it through the code above, produce 0 (the final number in the program).
# For this we only need to search through the range 0..7, and we treat the higher bits (accessed in the third instruction) as zero.
# Then we can solve for the 4th to 6th highest bits that will produce 3 (the second last number in the program), and so on.

program = [2,4,1,2,7,5,4,7,1,3,5,5,0,3,3,0]

test = fn a, out ->
    b1 = rem(a, 8)
    b2 = Bitwise.bxor(b1, 2)
    c  = div(a, 2**b2)
    b3 = Bitwise.bxor(b2, c)
    b4 = Bitwise.bxor(b3, 3)
    out == rem(b4, 8)
end

reduce(
    reverse(program),
    [0],
    fn out, as ->
        for a <- as,
            al <- 0..7,
            a2 = a * 8 + al,
            test.(a2, out)
            do
            a2
        end
    end
)
|> hd()
|> IO.inspect()